
Count moves
======================================================

To count the moves available for a player, our program iterates over every one of their pieces, checking each of the 4 directions for an available space. This check is performed in constant time.
Therefore the time complexity is O(n), where n is the number of pieces available to a player.

Since our program gets the total number of moves by generating moves one piece at a time, and summing their number without storing them, actually counting the moves only uses a constant amount of memory. However, it does so by iterating through a list of the pieces which is stored in an instance of Board class, which takes up O(n) of space. 

Massacre
======================================================

To generate the moves needed to massacre the other team, we have used a form of best-first search over nodes that contain Board objects, and a cost function:

	f(n) = g(n) + h(n)

g(n), the cost to reach the node, is simply the number of moves made from the original board state.
h(n), the estimated cost to reach the goal, is the number of black pieces remaining on the board.

h(n) is not admissible as there may be a cases where there are more black pieces than moves needed to eliminate them-- such as in the following case:

	O @ - @ O
	- - O - -

Here h(n) = 2, but only one move is needed to eliminate the black pieces. Therefore our search function is not always optimal, and may not return the shortest possible sequence of moves.

Our branching factor varies, as it is the number of available moves, but it has a maximum of 4x, where x is the starting number of white pieces on the board.

We have also capped our search depth at 5, since searching further is not required for this assessment.
